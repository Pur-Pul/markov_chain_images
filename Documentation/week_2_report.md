Since last week I have made some changes my idea. As stated in the feedback I recieved, markov chains work 2-dimensionally while images are 3-dimensional. This means that images can't be accurately generated by traversing the image one row at a time. Instead I opted to generate one chain for the whole image and then generate the image using BFS. BFS allows more natural looking patterns to to be generated, as the image will be generated outwards from a single point, compared pixel by pixel, one row at a time.  

I also now combine the probabilities of the neighboring nodes, when generating a node. Except for the first node, there will allways be atleast 1 neighbor that has already been generated, but there may be multiple. In the case of multiple neighbors, the probabilities are combined using the following equation: 
```python
(P(1) * P(2) * P(3) * P(4)) *!n | #n >= 1 and n <= 4.
```
n is ther number of probabilities to be combined. At the moment i only take the direct neighbors into account, which means it is 4 at most, but I may expand that in the future to the 8 surrounding neighbors.

I'm not really sure this equation is the best to use, as I came up with it through testing (couldn't find anything of value on Google). The reason for the !n is that I'm not trying to calculate the probability of two events happening toghether, but what the average probability is. The problem with calculating the average normally is that then a probability of 0 might be increased when combined with other non 0 probabilities. However this equation does not fix another problem which is the case where a probability of 0 is combined with a probability of 1. This seems to be an impossible situation to solve by just changing the equation, which means I would have to either change the algorithm in some way, or just go with a random color in such a situation.

This week I also implemented pytest and coverage, pylint, invoke and poetry to keep track of all the dependencies. Using pytest I can test the code and coverage creates a coverage report. Pylint allows me to keep my code tidy and readable. Invoke allows me to create simpler commands to run tests and the program itself. Pytest, Coverage and Pylint are in the dev side of Poetry, which means they won't be installed unless specified.  

Next week I will work on implementing my own random class and start implementing proper image input and output. I will also create more tests to get a more accurate coverage and tidy up the code using pylint.

Hours spent this week: 8